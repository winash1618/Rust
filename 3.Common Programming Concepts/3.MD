# Common Programming Concepts
- In this chapter youâ€™ll learn about variables, basic types, functions, comments, and control flow
## Variables and Mutability
- When a variable is immutable, once a value is bound to a name, you canâ€™t change that value. To illustrate this, letâ€™s generate a new project called variables in your projects directory by using cargo new variables.
- Then, in your new variables directory, open src/main.rs and replace its code with the following code. This code wonâ€™t compile just yet, weâ€™ll first examine the immutability error.
```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
- Although variables are immutable by default, you can make them mutable by adding mut in front of the variable name. for example:
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
- Weâ€™re allowed to change the value bound to x from 5 to 6 when mut is used. 
## Constants
- Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.
- First, you arenâ€™t allowed to use mut with constants. Constants arenâ€™t just immutable by defaultâ€”theyâ€™re always immutable. 
- You declare constants using the const keyword instead of the let keyword, and the type of the value must be annotated(Don't worry about annotation we'll discuss about it later).
- Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.
- The last difference is that constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.
- Rustâ€™s naming convention for constants is to use all uppercase with underscores between words.
- Here's an example of a constant declaration:
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
- Constants are valid for the entire time a program runs, within the scope they were declared in.
## Shadowing
- We can shadow a variable by using the same variableâ€™s name and repeating the use of the let keyword as follows:
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
- Shadowing is different from marking a variable as mut, because weâ€™ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword.
- The other difference between mut and shadowing is that because weâ€™re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example:
```rust
    let spaces = "   ";
    let spaces = spaces.len();
```
- The first spaces variable is a string type and the second spaces variable is a number type. Shadowing thus spares us from having to come up with different names, such as spaces_str and spaces_num; instead, we can reuse the simpler spaces name. However, if we try to use mut for this, as shown here, weâ€™ll get a compile-time error:
```rust
    let mut spaces = "   ";
    spaces = spaces.len();
```
## Data types
- Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data. Weâ€™ll look at two data type subsets: scalar and compound.
- Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
- If we donâ€™t add the : u32 type annotation above, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use.
### Scalar types
- A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.
- Integer types: An integer is a number without a fractional component.(Please refer this section for more details). Each variant can be either signed or unsigned and has an explicit size. 
- Floating point types: Rust also has two primitive types for floating-point numbers, which are numbers with decimal points. Rustâ€™s floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively. The default type is f64 because on modern CPUs itâ€™s roughly the same speed as f32 but is capable of more precision. All floating-point types are signed. example:
```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```
- The Boolean Type: As in most other programming languages, a Boolean type in Rust has two possible values: true and false. Booleans are one byte in size. The Boolean type in Rust is specified using bool. For example:
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
- The Character Type: Rustâ€™s char type is the languageâ€™s most primitive alphabetic type. Hereâ€™s some examples of declaring char values. Note that we specify char literals with single quotes, as opposed to string literals, which use double quotes. For example:
```rust
fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // with explicit type annotation
    let heart_eyed_cat = 'ðŸ˜»';
}
```
- Rustâ€™s char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.
### Compound types
- Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.
#### The tuple type:
- A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.
- We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple donâ€™t have to be the same. 
- Weâ€™ve added optional type annotations in this example:
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
- The variable tup binds to the entire tuple, because a tuple is considered a single compound element.
- To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:
```
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```
- This program first creates a tuple and binds it to the variable tup. It then uses a pattern with let to take tup and turn it into three separate variables, x, y, and z. This is called destructuring, because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.
- We can also access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
- The tuple without any values has a special name, unit.
### The Array Type
- Another way to have a collection of multiple values is with an array. For example:
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
}
```
- You write an arrayâ€™s type using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
- Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.
- You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:
```rust
let a = [3; 5];
```
- The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; but in a more concise way.
#### Accessing Array Elements
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
#### Invalid Array Element Access
