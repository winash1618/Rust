# Common Programming Concepts
- In this chapter you’ll learn about variables, basic types, functions, comments, and control flow
## Variables and Mutability
- When a variable is immutable, once a value is bound to a name, you can’t change that value. To illustrate this, let’s generate a new project called variables in your projects directory by using cargo new variables.
- Then, in your new variables directory, open src/main.rs and replace its code with the following code. This code won’t compile just yet, we’ll first examine the immutability error.
```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
- Although variables are immutable by default, you can make them mutable by adding mut in front of the variable name. for example:
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
- We’re allowed to change the value bound to x from 5 to 6 when mut is used. 
## Constants
- Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.
- First, you aren’t allowed to use mut with constants. Constants aren’t just immutable by default—they’re always immutable. 
- You declare constants using the const keyword instead of the let keyword, and the type of the value must be annotated(Don't worry about annotation we'll discuss about it later).
- Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.
- The last difference is that constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.
- Rust’s naming convention for constants is to use all uppercase with underscores between words.
- Here's an example of a constant declaration:
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
- Constants are valid for the entire time a program runs, within the scope they were declared in.
## Shadowing
- We can shadow a variable by using the same variable’s name and repeating the use of the let keyword as follows:
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
- Shadowing is different from marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword.
- The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example:
```rust
    let spaces = "   ";
    let spaces = spaces.len();
```
- The first spaces variable is a string type and the second spaces variable is a number type. Shadowing thus spares us from having to come up with different names, such as spaces_str and spaces_num; instead, we can reuse the simpler spaces name. However, if we try to use mut for this, as shown here, we’ll get a compile-time error:
```rust
    let mut spaces = "   ";
    spaces = spaces.len();
```